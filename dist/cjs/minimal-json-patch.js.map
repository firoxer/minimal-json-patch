{"version":3,"file":"minimal-json-patch.js","sources":["../../src/json-patch-error.js","../../src/util.js","../../src/pointer.js","../../src/index.js","../../src/compare.js"],"sourcesContent":["// TODO: Context\nexport class JsonPatchError extends Error {\n  describe(description) {\n    this.message = `${description}: ${this.message}`;\n  }\n}\n","export const isArray = Array.isArray; // For symmetry with `isObject`\n\nexport const isObject = (x) =>\n  x !== null && typeof x === 'object' && !Array.isArray(x);\n","import { JsonPatchError } from './json-patch-error.js';\nimport { isArray, isObject } from './util.js';\n\nfunction validatePath(path) {\n  if (typeof path !== 'string') {\n    throw new JsonPatchError(\n      `bad path: should be a string, was ${typeof path}`\n    );\n  }\n\n  if (path[0] !== '/' && path !== '') {\n    throw new JsonPatchError('bad path: should be \"\" or start with \"/\"');\n  }\n}\n\nfunction parseTokenString(tokenString, context) {\n  if (isObject(context)) {\n    const decodedTokenString =\n      tokenString\n        .replace('~1', '/')\n        .replace('~0', '~');\n    return decodedTokenString;\n  } else if (isArray(context)) {\n    if (tokenString === '-') {\n      return context.length;\n    }\n\n    const tokenNumber = parseInt(tokenString, 10);\n\n    if (isNaN(tokenNumber) || tokenNumber != tokenString) {\n      throw new JsonPatchError(\n        `path token is not a valid array index, was ${JSON.stringify(tokenString)}`\n      );\n    }\n\n    return tokenNumber;\n  } else {\n    throw new JsonPatchError(\n      `token context should either be an array or a string, was ${typeof context}`\n    );\n  }\n}\n\nexport class Pointer {\n  constructor(path) {\n    validatePath(path);\n\n    this.tokenStrings = path.split('/').slice(1);\n    this.nextTokenIndex = 0;\n  }\n\n  isPrefixTo(anotherPointer) {\n    if (!(anotherPointer instanceof Pointer)) {\n      throw new JsonPatchError(\n        `arg is not a pointer, was ${typeof anotherPointer}`\n      );\n    }\n\n    for (const [index, tokenString] of this.tokenStrings.entries()) {\n      if (tokenString !== anotherPointer.tokenStrings[index]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  tokensLeft() {\n    return this.tokenStrings.length - this.nextTokenIndex;\n  }\n\n  isFullyRead() {\n    return this.tokensLeft() <= 0;\n  }\n\n  readNextTokenInContext(contextItem) {\n    const tokenString = this.tokenStrings[this.nextTokenIndex];\n\n    if (tokenString === undefined) {\n      const validSection = this.tokenStrings\n        .slice(0, this.nextTokenIndex - 1)\n        .join('/');\n      throw new JsonPatchError(\n        `pointer is already fully read; valid section was \"${validSection}\"`\n      );\n    }\n\n    ++this.nextTokenIndex;\n\n    return parseTokenString(tokenString, contextItem);\n  }\n\n  rewind() {\n    this.nextTokenIndex = 0;\n  }\n}\n","import { compare } from './compare.js';\nimport { JsonPatchError } from './json-patch-error.js';\nimport { Pointer } from './pointer.js';\nimport { isArray, isObject } from './util.js';\n\nexport { JsonPatchError };\n\nfunction has(element, pointer) {\n  if (pointer.isFullyRead()) {\n    return true;\n  }\n\n  const index = pointer.readNextTokenInContext(element);\n\n  if (element[index] === undefined) {\n    return false;\n  }\n\n  return has(element[index], pointer);\n}\n\nfunction get(element, pointer) {\n  if (pointer.isFullyRead()) {\n    return element;\n  }\n\n  const index = pointer.readNextTokenInContext(element);\n\n  if (element[index] === undefined) {\n    throw new JsonPatchError('pointer does not lead anywhere');\n  }\n\n  return get(element[index], pointer);\n}\n\nfunction add(element, pointer, value) {\n  const index = pointer.readNextTokenInContext(element);\n\n  let modifiedMember;\n  if (pointer.isFullyRead()) {\n    modifiedMember = value;\n  } else {\n    const deeperElement = element[index];\n\n    if (!isArray(deeperElement) && !isObject(deeperElement)) {\n      throw new JsonPatchError(\n        `pointer leads to an element that is neither an array nor an object but ${typeof deeperElement}`\n      );\n    }\n\n    modifiedMember = add(deeperElement, pointer, value);\n  }\n\n  if (isArray(element)) {\n    if (index > element.length) {\n      throw new JsonPatchError(`pointer points to an index that is out-of-bounds`);\n    }\n\n    const newElement = [...element];\n    newElement.splice(index, 0, modifiedMember);\n    return newElement;\n  } else {\n    const newElement = { ...element };\n    newElement[index] = modifiedMember;\n    return newElement;\n  }\n}\n\nfunction replace(element, pointer, value) {\n  const index = pointer.readNextTokenInContext(element);\n\n  let modifiedMember;\n  if (pointer.isFullyRead()) {\n    modifiedMember = value;\n  } else {\n    const deeperElement = element[index];\n\n    if (!isArray(deeperElement) && !isObject(deeperElement)) {\n      throw new JsonPatchError(\n        `pointer leads to an element that is neither an array nor an object but ${typeof deeperElement}`\n      );\n    }\n\n    modifiedMember = replace(deeperElement, pointer, value);\n  }\n\n  if (isArray(element)) {\n    const newElement = [...element];\n    newElement.splice(index, 1, modifiedMember);\n    return newElement;\n  } else {\n    const newElement = { ...element };\n    newElement[index] = modifiedMember;\n    return newElement;\n  }\n}\n\nfunction remove(element, pointer) {\n  const index = pointer.readNextTokenInContext(element);\n\n  if (pointer.isFullyRead()) {\n    if (element[index] === undefined) {\n      throw new JsonPatchError(`pointer does not lead anywhere`);\n    }\n\n    if (isArray(element)) {\n      const newElement = [...element];\n      newElement.splice(index, 1);\n      return newElement;\n    } else {\n      const newElement = { ...element };\n      delete newElement[index];\n      return newElement;\n    }\n  }\n\n  const deeperElement = element[index];\n\n  if (!isArray(deeperElement) && !isObject(deeperElement)) {\n    throw new JsonPatchError(\n      `pointer leads to an element that is neither an array nor an object but ${typeof deeperElement}`\n    );\n  }\n\n  const modifiedMember = remove(deeperElement, pointer);\n\n  if (isArray(element)) {\n    const newElement = [...element];\n    newElement.splice(index, 1, modifiedMember);\n    return newElement;\n  } else {\n    const newElement = { ...element };\n    newElement[index] = modifiedMember;\n    return newElement;\n  }\n}\n\nfunction applyOperation(document, operation) {\n  switch (operation.op) {\n    case 'add':\n      try {\n        if (!('value' in operation)) {\n          throw new JsonPatchError('missing value');\n        }\n\n        if (operation.path === '') {\n          // Since the destination of the addition is root itself, we can just\n          // return the operation value directly\n          return operation.value;\n        }\n\n        return add(document, new Pointer(operation.path), operation.value);\n      } catch (e) {\n        if (e instanceof JsonPatchError) {\n          e.describe('add failed');\n        }\n        throw e;\n      }\n\n    case 'copy':\n      try {\n        if (!('from' in operation)) {\n          throw new JsonPatchError('missing from');\n        }\n\n        const value = get(document, new Pointer(operation.from));\n\n        if (operation.path === '') {\n          // Since the destination of the copy is root itself, we can just\n          // return the source of the copy directly\n          return value;\n        }\n\n        return add(document, new Pointer(operation.path), value);\n      } catch (e) {\n        if (e instanceof JsonPatchError) {\n          e.describe('copy failed');\n        }\n        throw e;\n      }\n\n    case 'move':\n      try {\n        if (!('from' in operation)) {\n          throw new JsonPatchError('missing from');\n        }\n\n        if (operation.from === operation.path) {\n          // No-op\n          return document;\n        }\n\n        const fromPointer = new Pointer(operation.from);\n        const pathPointer = new Pointer(operation.path);\n\n        if (fromPointer.isPrefixTo(pathPointer)) {\n          throw new JsonPatchError(\n            'from pointer cannot be a prefix of path pointer'\n          );\n        }\n\n        const value = get(document, fromPointer);\n\n        if (operation.path === '') {\n          // Since the destination of the move is root itself, we can just\n          // return the source of the move directly\n          return value;\n        }\n\n        document = replace(document, pathPointer, value);\n\n        if (pathPointer.isPrefixTo(fromPointer)) {\n          // No need to remove anything since the \"from\" element has already\n          // taken the place of the \"path\" element\n          return document;\n        }\n\n        fromPointer.rewind();\n        return remove(document, fromPointer);\n      } catch (e) {\n        if (e instanceof JsonPatchError) {\n          e.describe('move failed');\n        }\n        throw e;\n      }\n\n    case 'remove':\n      try {\n        if (operation.path === '') {\n          // When deleting the root of the document, the outcome is undefined,\n          // so let's return `null` and hope that's good enough\n          return null;\n        }\n\n        return remove(document, new Pointer(operation.path));\n      } catch (e) {\n        if (e instanceof JsonPatchError) {\n          e.describe('remove failed');\n        }\n        throw e;\n      }\n\n    case 'replace':\n      try {\n        if (!('value' in operation)) {\n          throw new JsonPatchError('missing value');\n        }\n\n        if (operation.path === '') {\n          // Since the destination of the replacement is root itself, we can\n          // just return the intended replacement value directly\n          return operation.value;\n        }\n\n        const pathPointer = new Pointer(operation.path);\n\n        if (!has(document, pathPointer)) {\n          throw new JsonPatchError('pointer points to a nonexistent location');\n        }\n\n        pathPointer.rewind();\n\n        return replace(document, pathPointer, operation.value);\n      } catch (e) {\n        if (e instanceof JsonPatchError) {\n          e.describe('replace failed');\n        }\n        throw e;\n      }\n\n    case 'test':\n      try {\n        if (!('value' in operation)) {\n          throw new JsonPatchError('missing value');\n        }\n\n        compare(operation.value, get(document, new Pointer(operation.path)));\n\n        return document; // Unchanged as it should\n      } catch (e) {\n        if (e instanceof JsonPatchError) {\n          e.describe('test failed');\n        }\n        throw e;\n      }\n\n    default:\n      throw new JsonPatchError(\n        `illegal op: should be add/copy/move/remove/replace/test, was ${JSON.stringify(operation.op)}`\n      );\n  }\n}\n\nexport function applyPatch(document, patch) {\n  if (!Array.isArray(patch)) {\n    throw new JsonPatchError('bad patch: should be an array of operations');\n  }\n\n  for (const operation of patch) {\n    document = applyOperation(document, operation);\n  }\n\n  return document;\n}\n","import { JsonPatchError } from './json-patch-error.js';\nimport { isArray, isObject } from './util.js';\n\nfunction compareObject(object, value) {\n  if (!isObject(value)) {\n    throw new JsonPatchError('test target is an object but the value is not');\n  }\n\n  if (Object.keys(object).length !== Object.keys(value).length) {\n    throw new JsonPatchError(\n      'test target has a different number of keys than the compared value'\n    );\n  }\n\n  for (const valueKey in value) {\n    if (!(valueKey in object)) {\n      throw new JsonPatchError(`test target lacks a key: ${valueKey}`);\n    }\n  }\n\n  for (const key in object) {\n    if (!(key in value)) {\n      throw new JsonPatchError(`test target has an extra key: ${key}`);\n    }\n  }\n\n  for (const valueKey in value) {\n    compare(object[valueKey], value[valueKey]);\n  }\n}\n\nfunction compareArray(array, value) {\n  if (!isArray(value)) {\n    throw new JsonPatchError('test target is an array but the value is not');\n  }\n\n  if (array.length !== value.length) {\n    throw new JsonPatchError(\n      'test target and value are arrays of differing length'\n    );\n  }\n\n  for (let i = 0; i < array.length; ++i) {\n    compare(array[i], value[i]);\n  }\n}\n\nfunction comparePrimitive(primitive, value) {\n  if (primitive !== value) {\n    throw new JsonPatchError(\n      `${primitive} is not equal to ${JSON.stringify(value)}`\n    );\n  }\n}\n\nexport function compare(item, value) {\n  if (isObject(item)) {\n    compareObject(item, value);\n  } else if (isArray(item)) {\n    compareArray(item, value);\n  } else {\n    comparePrimitive(item, value);\n  }\n}\n"],"names":["JsonPatchError","describe","description","this","message","Error","isArray","Array","isObject","x","Pointer","path","validatePath","tokenStrings","split","slice","nextTokenIndex","isPrefixTo","anotherPointer","entries","tokensLeft","length","isFullyRead","readNextTokenInContext","contextItem","tokenString","undefined","validSection","join","context","replace","tokenNumber","parseInt","isNaN","JSON","stringify","parseTokenString","rewind","get","element","pointer","index","add","value","modifiedMember","deeperElement","newElement","splice","remove","applyOperation","document","operation","op","e","from","fromPointer","pathPointer","has","compare","item","object","Object","keys","valueKey","key","compareObject","array","i","compareArray","primitive","comparePrimitive","patch"],"mappings":"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"}