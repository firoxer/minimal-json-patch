function t(){return(t=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t}).apply(this,arguments)}function e(t){return(e=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function n(t,e){return(n=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function r(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(t){return!1}}function o(t,e,i){return(o=r()?Reflect.construct:function(t,e,r){var o=[null];o.push.apply(o,e);var i=new(Function.bind.apply(t,o));return r&&n(i,r.prototype),i}).apply(null,arguments)}function i(t){var r="function"==typeof Map?new Map:void 0;return(i=function(t){if(null===t||-1===Function.toString.call(t).indexOf("[native code]"))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,i)}function i(){return o(t,arguments,e(this).constructor)}return i.prototype=Object.create(t.prototype,{constructor:{value:i,enumerable:!1,writable:!0,configurable:!0}}),n(i,t)})(t)}function a(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=new Array(e);n<e;n++)r[n]=t[n];return r}function f(t,e){var n;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(n=function(t,e){if(t){if("string"==typeof t)return a(t,void 0);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?a(t,void 0):void 0}}(t))||e&&t&&"number"==typeof t.length){n&&(t=n);var r=0;return function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}return(n=t[Symbol.iterator]()).next.bind(n)}var u=function(t){var e,n;function r(){return t.apply(this,arguments)||this}return n=t,(e=r).prototype=Object.create(n.prototype),e.prototype.constructor=e,e.__proto__=n,r.prototype.describe=function(t){this.message=t+": "+this.message},r}(i(Error)),s=Array.isArray,c=function(t){return null!==t&&"object"==typeof t&&!Array.isArray(t)},l=function(){function t(t){!function(t){if("string"!=typeof t)throw new u("bad path: should be a string, was "+typeof t);if("/"!==t[0]&&""!==t)throw new u('bad path: should be "" or start with "/"')}(t),this.tokenStrings=t.split("/").slice(1),this.nextTokenIndex=0}var e=t.prototype;return e.isPrefixTo=function(e){if(!(e instanceof t))throw new u("arg is not a pointer, was "+typeof e);for(var n,r=f(this.tokenStrings.entries());!(n=r()).done;){var o=n.value;if(o[1]!==e.tokenStrings[o[0]])return!1}return!0},e.tokensLeft=function(){return this.tokenStrings.length-this.nextTokenIndex},e.isFullyRead=function(){return this.tokensLeft()<=0},e.readNextTokenInContext=function(t){var e=this.tokenStrings[this.nextTokenIndex];if(void 0===e){var n=this.tokenStrings.slice(0,this.nextTokenIndex-1).join("/");throw new u('pointer is already fully read; valid section was "'+n+'"')}return++this.nextTokenIndex,function(t,e){if(c(e))return t.replace("~1","/").replace("~0","~");if(s(e)){if("-"===t)return e.length;var n=parseInt(t,10);if(isNaN(n)||n!=t)throw new u("path token is not a valid array index, was "+JSON.stringify(t));return n}throw new u("token context should either be an array or a string, was "+typeof e)}(e,t)},e.rewind=function(){this.nextTokenIndex=0},t}();function h(t,e){if(e.isFullyRead())return t;var n=e.readNextTokenInContext(t);if(void 0===t[n])throw new u("pointer does not lead anywhere");return h(t[n],e)}function p(e,n,r){var o,i=n.readNextTokenInContext(e);if(n.isFullyRead())o=r;else{var a=e[i];if(!s(a)&&!c(a))throw new u("pointer leads to an element that is neither an array nor an object but "+typeof a);o=p(a,n,r)}if(s(e)){if(i>e.length)throw new u("pointer points to an index that is out-of-bounds");var f=[].concat(e);return f.splice(i,0,o),f}var l=t({},e);return l[i]=o,l}function d(e,n,r){var o,i=n.readNextTokenInContext(e);if(n.isFullyRead())o=r;else{var a=e[i];if(!s(a)&&!c(a))throw new u("pointer leads to an element that is neither an array nor an object but "+typeof a);o=d(a,n,r)}if(s(e)){var f=[].concat(e);return f.splice(i,1,o),f}var l=t({},e);return l[i]=o,l}function w(e,n){var r=n.readNextTokenInContext(e);if(n.isFullyRead()){if(void 0===e[r])throw new u("pointer does not lead anywhere");if(s(e)){var o=[].concat(e);return o.splice(r,1),o}var i=t({},e);return delete i[r],i}var a=e[r];if(!s(a)&&!c(a))throw new u("pointer leads to an element that is neither an array nor an object but "+typeof a);var f=w(a,n);if(s(e)){var l=[].concat(e);return l.splice(r,1,f),l}var h=t({},e);return h[r]=f,h}function y(t,e){switch(e.op){case"add":try{if(!("value"in e))throw new u("missing value");return""===e.path?e.value:p(t,new l(e.path),e.value)}catch(t){throw t instanceof u&&t.describe("add failed"),t}case"copy":try{if(!("from"in e))throw new u("missing from");var n=h(t,new l(e.from));return""===e.path?n:p(t,new l(e.path),n)}catch(t){throw t instanceof u&&t.describe("copy failed"),t}case"move":try{if(!("from"in e))throw new u("missing from");if(e.from===e.path)return t;var r=new l(e.from),o=new l(e.path);if(r.isPrefixTo(o))throw new u("from pointer cannot be a prefix of path pointer");var i=h(t,r);return""===e.path?i:(t=d(t,o,i),o.isPrefixTo(r)?t:(r.rewind(),w(t,r)))}catch(t){throw t instanceof u&&t.describe("move failed"),t}case"remove":try{return""===e.path?null:w(t,new l(e.path))}catch(t){throw t instanceof u&&t.describe("remove failed"),t}case"replace":try{if(!("value"in e))throw new u("missing value");if(""===e.path)return e.value;var a=new l(e.path);if(!function t(e,n){if(n.isFullyRead())return!0;var r=n.readNextTokenInContext(e);return void 0!==e[r]&&t(e[r],n)}(t,a))throw new u("pointer points to a nonexistent location");return a.rewind(),d(t,a,e.value)}catch(t){throw t instanceof u&&t.describe("replace failed"),t}case"test":try{if(!("value"in e))throw new u("missing value");return function t(e,n){c(e)?function(e,n){if(!c(n))throw new u("test target is an object but the value is not");if(Object.keys(e).length!==Object.keys(n).length)throw new u("test target has a different number of keys than the compared value");for(var r in n)if(!(r in e))throw new u("test target lacks a key: "+r);for(var o in e)if(!(o in n))throw new u("test target has an extra key: "+o);for(var i in n)t(e[i],n[i])}(e,n):s(e)?function(e,n){if(!s(n))throw new u("test target is an array but the value is not");if(e.length!==n.length)throw new u("test target and value are arrays of differing length");for(var r=0;r<e.length;++r)t(e[r],n[r])}(e,n):function(t,e){if(t!==e)throw new u(t+" is not equal to "+JSON.stringify(e))}(e,n)}(e.value,h(t,new l(e.path))),t}catch(t){throw t instanceof u&&t.describe("test failed"),t}default:throw new u("illegal op: should be add/copy/move/remove/replace/test, was "+JSON.stringify(e.op))}}function v(t,e){if(!Array.isArray(e))throw new u("bad patch: should be an array of operations");for(var n,r=f(e);!(n=r()).done;)t=y(t,n.value);return t}export{u as JsonPatchError,v as applyPatch};
//# sourceMappingURL=minimal-json-patch.js.map
