{"version":3,"file":"index.js","sources":["../src/json-patch-error.js","../src/util.js","../src/pointer.js","../src/index.js","../src/compare.js"],"sourcesContent":["// TODO: Context\nexport class JsonPatchError extends Error {\n  describe(description) {\n    this.message = `${description}: ${this.message}`;\n  }\n}","export const isArray = Array.isArray; // For symmetry with `isObject`\n\nexport const isObject = (x) => x !== null && typeof x === 'object' && !Array.isArray(x);","import { JsonPatchError } from './json-patch-error.js';\nimport { isArray, isObject } from './util.js';\n\nfunction validatePath(path) {\n  if (typeof path !== 'string') {\n    throw new JsonPatchError(`bad path: should be a string, was ${typeof path}`);\n  }\n  if (path[0] !== '/' && path !== '') {\n    throw new JsonPatchError('bad path: should be \"\" or start with \"/\"');\n  }\n}\n\nfunction parseTokenString(tokenString, contextItem) {\n  if (isObject(contextItem)) {\n    const decodedTokenString = tokenString.replace('~1', '/').replace('~0', '~');\n    return decodedTokenString;\n  } else if (isArray(contextItem)) {\n    if (tokenString === '-') {\n      return contextItem.length;\n    }\n\n    const tokenNumber = parseInt(tokenString, 10);\n\n    if (isNaN(tokenNumber) || tokenNumber != tokenString) {\n      throw new JsonPatchError(`path token is not a valid array index, was ${tokenString}`);\n    }\n\n    return tokenNumber;\n  } else {\n    throw new JsonPatchError(`token context should either be an array or a string, was ${typeof contextItem}`);\n  }\n}\n\nexport class Pointer {\n  constructor(path, prefix) {\n    validatePath(path);\n\n    this.tokenStrings = path.split('/').slice(1);\n    this.nextTokenIndex = 0;\n\n    if (prefix !== undefined) {\n      validatePath(prefix);\n      this.tokenStrings = [...prefix.split('/').slice(1), ...this.tokenStrings];\n    }\n  }\n\n  tokensLeft() {\n    return this.tokenStrings.length - this.nextTokenIndex;\n  }\n\n  isFullyRead() {\n    return this.tokensLeft() <= 0;\n  }\n\n  readNextTokenInContext(contextItem) {\n    const tokenString = this.tokenStrings[this.nextTokenIndex];\n\n    if (tokenString === undefined) {\n      const validSection = this.tokenStrings.slice(0, this.nextTokenIndex - 1).join('/');\n      throw new JsonPatchError(`pointer is already fully read; valid section was \"${validSection}\"`);\n    }\n\n    ++this.nextTokenIndex;\n\n    return parseTokenString(tokenString, contextItem);\n  }\n}","import { compare } from './compare.js';\nimport { JsonPatchError } from './json-patch-error.js';\nimport { Pointer } from './pointer.js';\nimport { isArray, isObject } from './util.js';\n\nexport { JsonPatchError };\n\nfunction has(element, pointer) {\n  if (pointer.isFullyRead()) {\n    return true;\n  }\n\n  const index = pointer.readNextTokenInContext(element);\n\n  if (element[index] === undefined) {\n    return false;\n  }\n\n  return has(element[index], pointer);\n}\n\nfunction get(element, pointer) {\n  if (pointer.isFullyRead()) {\n    return element;\n  }\n\n  const index = pointer.readNextTokenInContext(element);\n\n  if (element[index] === undefined) {\n    throw new JsonPatchError(`path does not lead anywhere`);\n  }\n\n  return get(element[index], pointer);\n}\n\nfunction set(element, pointer, value) {\n  const index = pointer.readNextTokenInContext(element);\n\n  let modifiedMember;\n  if (pointer.isFullyRead()) {\n    modifiedMember = value;\n  } else {\n    const deeperElement = element[index];\n\n    if (!isArray(deeperElement) && !isObject(deeperElement)) {\n      throw new JsonPatchError(`path leads to an element that is neither an array nor an object but ${typeof deeperElement}`);\n    }\n\n    modifiedMember = set(deeperElement, pointer, value);\n  }\n\n  if (isArray(element)) {\n    const newElement = [...element];\n    newElement.splice(index, 1, modifiedMember);\n    return newElement;\n  } else {\n    const newElement = { ...element };\n    newElement[index] = modifiedMember;\n    return newElement;\n  }\n}\n\nfunction remove(element, pointer) {\n  const index = pointer.readNextTokenInContext(element);\n\n  if (pointer.isFullyRead()) {\n    if (element[index] === undefined) {\n      throw new JsonPatchError(`path does not lead anywhere`);\n    }\n\n    if (isArray(element)) {\n      const newElement = [...element];\n      newElement.splice(index, 1);\n      return newElement;\n    } else {\n      const newElement = { ...element };\n      delete newElement[index];\n      return newElement;\n    }\n  }\n\n  const deeperElement = element[index];\n\n  if (!isArray(deeperElement) && !isObject(deeperElement)) {\n    throw new JsonPatchError(`path leads to an element that is neither an array nor an object but ${typeof deeperElement}`);\n  }\n\n  const modifiedMember = remove(deeperElement, pointer);\n\n  if (isArray(element)) {\n    const newElement = [...element];\n    newElement.splice(index, 1, modifiedMember);\n    return newElement;\n  } else {\n    const newElement = { ...element };\n    newElement[index] = modifiedMember;\n    return newElement;\n  }\n}\n\nexport function apply(document, patch) {\n  if (!Array.isArray(patch)) {\n    throw new JsonPatchError('bad patch: should be an array of operations')\n  }\n\n  // Wrapping the processed document and prefixing operations' paths with `/document`\n  // lets us work with far fewer ifs and elses\n  let wrappedDocument = { document };\n\n  for (const operation of patch) {\n    const createPathPointer = () => new Pointer(operation.path, '/document');\n    const fromPointer = 'from' in operation ? new Pointer(operation.from, '/document') : null;\n\n    switch (operation.op) {\n      case 'add':\n        try {\n          wrappedDocument = set(wrappedDocument, createPathPointer(), operation.value);\n        } catch (e) {\n          e.describe('add failed');\n          throw e;\n        }\n        break;\n\n      case 'copy':\n        try {\n          const value = get(wrappedDocument, fromPointer);\n          wrappedDocument = set(wrappedDocument, createPathPointer(), value);\n        } catch (e) {\n          e.describe('copy failed');\n          throw e;\n        }\n        break;\n\n      case 'move':\n        try {\n          const value = get(wrappedDocument, fromPointer);\n          wrappedDocument = set(wrappedDocument, createPathPointer(), value);\n          wrappedDocument = remove(wrappedDocument, fromPointer);\n        } catch (e) {\n          e.describe('move failed');\n          throw e;\n        }\n        break;\n\n      case 'remove':\n        try {\n          wrappedDocument = remove(wrappedDocument, createPathPointer());\n        } catch (e) {\n          e.describe('remove failed');\n          throw e;\n        }\n        break;\n\n      case 'replace':\n        try {\n          if (!has(wrappedDocument, createPathPointer())) {\n            throw new JsonPatchError('path points to a nonexistent location');\n          }\n\n          wrappedDocument = set(wrappedDocument, createPathPointer(), operation.value);\n        } catch (e) {\n          e.describe('replace failed');\n          throw e;\n        }\n        break;\n\n      case 'test':\n        try {\n          compare(operation.value, get(wrappedDocument, createPathPointer()));\n        } catch (e) {\n          e.describe('test failed');\n          throw e;\n        }\n        break;\n\n      default:\n        throw new JsonPatchError(\n          `illegal op: should be add/copy/move/remove/replace/test, was ${operation.op}`\n        );\n    }\n  }\n\n  return wrappedDocument.document;\n}","import { JsonPatchError } from './json-patch-error.js';\nimport { isArray, isObject } from './util.js';\n\nfunction compareObject(object, value) {\n  if (!isObject(value)) {\n    throw new JsonPatchError('test target is an object but the value is not');\n  }\n\n  if (Object.keys(object).length !== Object.keys(value).length) {\n    throw new JsonPatchError('test target has a different number of keys than the compared value');\n  }\n\n  for (const valueKey in value) {\n    if (!(valueKey in object)) {\n      throw new JsonPatchError(`test target lacks a key: ${valueKey}`)\n    }\n  }\n\n  for (const key in object) {\n    if (!(key in value)) {\n      throw new JsonPatchError(`test target has an extra key: ${key}`)\n    }\n  }\n\n  for (const valueKey in value) {\n    compare(object[valueKey], value[valueKey]);\n  }\n}\n\nfunction compareArray(array, value) {\n  if (!isArray(value)) {\n    throw new JsonPatchError('test target is an array but the value is not');\n  }\n\n  if (array.length !== value.length) {\n    throw new JsonPatchError('test target and value are arrays of differing length');\n  }\n\n  for (let i = 0; i < array.length; ++i) {\n    compare(array[i], value[i]);\n  }\n}\n\nfunction comparePrimitive(primitive, value) {\n  if (primitive !== value) {\n    throw new JsonPatchError(`${primitive} is not equal to ${JSON.stringify(value)}`);\n  }\n}\n\nexport function compare(item, value) {\n  if (isObject(item)) {\n    compareObject(item, value);\n  } else if (isArray(item)) {\n    compareArray(item, value);\n  } else {\n    comparePrimitive(item, value);\n  }\n}"],"names":["JsonPatchError","describe","description","this","message","Error","isArray","Array","isObject","x","validatePath","path","Pointer","prefix","tokenStrings","split","slice","nextTokenIndex","undefined","tokensLeft","length","isFullyRead","readNextTokenInContext","contextItem","tokenString","validSection","join","replace","tokenNumber","parseInt","isNaN","parseTokenString","get","element","pointer","index","set","value","modifiedMember","deeperElement","newElement","splice","remove","document","patch","wrappedDocument","operation","createPathPointer","fromPointer","from","op","e","has","compare","item","object","Object","keys","valueKey","key","compareObject","array","i","compareArray","primitive","JSON","stringify","comparePrimitive"],"mappings":"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"}